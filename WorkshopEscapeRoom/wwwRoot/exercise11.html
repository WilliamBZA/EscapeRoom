<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Escape room fun!</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
</head>

<body>
    <div>
        <div class="container">
            <nav class="navbar navbar-expand-lg navbar-light bg-light">
                <div class="container-fluid">
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                            <li class="nav-item dropdown">
                                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Exercises</a>
                                <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                                    <li><a class="dropdown-item" href="exercise1.html">Exercise 1 - Intro to NanoFramework</a></li>
                                    <li><a class="dropdown-item" href="exercise2.html">Exercise 2 - Turning devices on/off</a></li>
                                    <li><a class="dropdown-item" href="exercise3.html">Exercise 3 - Responding to HTTP requests</a></li>
                                    <li><a class="dropdown-item" href="exercise4.html">Exercise 4 - Intro to Azure Service Bus</a></li>
                                    <li><a class="dropdown-item" href="exercise5.html">Exercise 5 - Pub/Sub</a></li>
                                    <li><a class="dropdown-item" href="exercise6.html">Exercise 6 - Dealing with failures</a></li>
                                    <li><a class="dropdown-item" href="exercise7.html">Exercise 7 - Building an efficient pipeline</a></li>
                                    <li><a class="dropdown-item" href="exercise8.html">Exercise 8 - Message Timeouts</a></li>
                                    <li><a class="dropdown-item" href="exercise9.html">Exercise 9 - Rate Limiting</a></li>
                                    <li><a class="dropdown-item" href="exercise10.html">Exercise 10 - Delayed Delivery</a></li>
                                    <li><a class="dropdown-item active" href="exercise11.html">Exercise 11 - Further patterns to learn</a></li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://github.com/WilliamBZA/1DayDistributedSystemsThroughPlay/tree/main/">Code Repo</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://github.com/WilliamBZA/1DayDistributedSystemsThroughPlay/tree/main/exercises/solutions">Solutions</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>

        <div class="container heading">
            <div>
                <h1>Exercise 11:</h1>
                <h4>What's Next: Building Real-World Distributed Systems</h4>
            </div>
        </div>
        
        <div class="container exercisedetails">
            <div class="col-lg-12">
                <ul class="nav nav-tabs" id="exercise-headings" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="gpio-tab" type="button" data-bs-toggle="tab" data-bs-target="#gpio-tab-content" role="tab" aria-controls="visualstudio-tab-content" aria-selected="false">
                            Further learning
                        </button>
                    </li>
                </ul>
                
                <div class="tab-content" id="exerciseContent">
                    <div class="tab-pane show active" id="gpio-tab-content" role="tabpanel" aria-labelledby="gpio-tab" tabindex="0">
                        <div>
                            So, you've made it this far! Nice work! You've learned to send messages, handle failures, manage retries,
                            and even send messages to the future with scheduling. But distributed systems are like onions (or ogres, if you're into Shrek quotes): they have layers.
                        </div>
                        <div>
                            As you head back to your own systems and start designing more complex architectures, here are some advanced patterns and concepts you'll want to explore.
                            These aren't all required on day one, but knowing they exist will help you grow toward more resilient, maintainable, and scalable systems.
                        </div>

                        <h3 class="breadcrumb" id="vs-step1">1. Inbox Pattern</h3>
                        <div>
                            Sometimes, a service receives the same message more than once. Maybe it's due to retries, or maybe it's from a sender trying
                            to guarantee delivery. To avoid doing the same work multiple times (like charging a customer twice), the Inbox pattern keeps
                            track of messages you've already handled.
                        </div>
                        <div>
                            Azure Service Bus guarantees at least once processing. The natural conclusion of this is that there is a chance that a message from Azure
                            Service Bus could be processed more than once. Having an implementation of the Inbox pattern can help prevent duplicate message processing.
                        </div>
                        <div class="note">
                            📝 Look into: storing processed message IDs for a while.
                        </div>

                        <h3 class="breadcrumb" id="vs-step2">2. Outbox Pattern</h3>
                        <div>
                            You've already seen how systems can fail between database writes and message publishing. The Outbox pattern helps solve this by storing
                            outgoing messages in your primary database as part of the same transaction.
                        </div>
                        <div>
                            Only after your business operation is safely committed do you send the messages out. This keeps state consistent and avoids the dreaded
                            "but I already updated the record!" bug when the message wasn't sent.
                        </div>
                        <div class="note">
                            📝 Look into: Maintaining a list of messages that have been successfully sent and which message ID triggered them.
                        </div>

                        <h3 class="breadcrumb" id="vs-step3">3. Orchestration and Sagas</h3>
                        <div>
                            What happens when a business process spans multiple services? Like a customer order that needs payment, inventory allocation, and
                            shipping: all handled by different services?
                        </div>
                        <div>
                            That's where Sagas come in. They're long-running transactions that coordinate multiple steps across services, using messages to
                            track progress. If something fails midway, a Saga can trigger compensating actions to roll things back.
                        </div>
                        <div class="note">
                            📝 You can implement these yourself using messages and state tracking, or explore tools like NServiceBus, MassTransit, Wolverine, or Akka.NET.
                        </div>

                        <h3 class="breadcrumb" id="vs-step4">4. Bridge Pattern</h3>
                        <div>
                            Sometimes, your systems don't speak the same protocol. One service might use Azure Service Bus, another might be on RabbitMQ, or maybe even HTTP.
                            The Bridge Pattern is a piece of software that listens in one place and republishes messages somewhere else - acting as a translator or a connector.
                        </div>
                        <div>
                            This is great for migrating systems, building hybrid clouds, or integrating with third-party platforms.
                        </div>
                        <div>
                            It's also incredibly useful as a tool to modernize legacy systems. Old parts of the system can use RPC or an old queueing technology while
                            the newer parts can use newer brokers. The old system and the new system don't need to know which part is using the old technology and which
                            is using the newer.
                        </div>

                        <h3 class="breadcrumb" id="vs-step5">5. DLQ Management</h3>
                        <div>
                            You've seen how messages get sent to the DLQ when they can't be processed. But then what?
                        </div>
                        <div>
                            DLQs are not the end of the road. Once a message ends up in the DLQ, you still need to decide how to deal with it. Some ideas:
                            <ul>
                                <li>Inspect and analyze failed messages.</li>
                                <li>Build automated retry flows.</li>
                                <li>Create dashboards to monitor them.</li>
                                <li>Use alerting tools when message counts spike.</li>
                            </ul>
                        </div>
                        <div class="note">
                            Tools like Service Bus Explorer, or AppInsights can be invaluable for helping you manage your deal-letter queues.
                        </div>

                        <h3 class="breadcrumb" id="vs-step6">6. Message Ordering and FIFO</h3>
                        <div>
                            Sometimes, the order messages arrive matters. Azure Service Bus lets you set Session IDs for ordered message processing.
                            This can help when you're building things like chat systems, command queues, or anything where "first come, first serve" matters.
                        </div>
                        <div class="note">
                            Explore Azure Service Bus Sessions to guarantee order of message processing.
                        </div>

                        <h3 class="breadcrumb" id="vs-step7">Monitoring and Observability</h3>
                        <div>
                            Distributed systems are... distributed. If something goes wrong, logs on your local machine won't be enough. You'll need:
                            <ul>
                                <li>Centralized logging (Azure Monitor, Seq, ELK)</li>
                                <li>Tracing and correlation IDs</li>
                                <li>Dashboards that show message throughput and failure rates</li>
                                <li>Alerts that warn you before things melt down</li>
                            </ul>
                        </div>
                        <div class="note">
                            Explore OTEL as a way to add observability and traceability to your system.
                        </div>

                        <h3 class="breadcrumb" id="vs-step8">Wrapping up</h3>
                        <div>
                            Distributed systems can be tricky, but they don't have to be terrifying. With the patterns and tools you've learned
                            in this workshop you're well on your way to building systems that are reliable, recoverable, and ready to scale. 🚀
                        </div>
<<<<<<< Updated upstream
=======
                    </div>
                    <div class="footer-nav">
                        <a href="exercise10.html">&lt; Go to Exercise 10</a>
>>>>>>> Stashed changes
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>