<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Escape room fun!</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
</head>

<body>
    <div>
        <div class="container">
            <nav class="navbar navbar-expand-lg navbar-light bg-light">
                <div class="container-fluid">
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                            <li class="nav-item dropdown">
                                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Exercises</a>
                                <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                                    <li><a class="dropdown-item" href="exercise1.html">Exercise 1 - Intro to NanoFramework</a></li>
                                    <li><a class="dropdown-item" href="exercise2.html">Exercise 2 - Turning devices on/off</a></li>
                                    <li><a class="dropdown-item" href="exercise3.html">Exercise 3 - Responding to HTTP requests</a></li>
                                    <li><a class="dropdown-item" href="exercise4.html">Exercise 4 - Intro to Azure Service Bus</a></li>
                                    <li><a class="dropdown-item" href="exercise5.html">Exercise 5 - Pub/Sub</a></li>
                                    <li><a class="dropdown-item" href="exercise6.html">Exercise 6 - Dealing with failures</a></li>
                                    <li><a class="dropdown-item" href="exercise7.html">Exercise 7 - Building an efficient pipeline</a></li>
                                    <li><a class="dropdown-item" href="exercise8.html">Exercise 8 - Message Timeouts</a></li>
                                    <li><a class="dropdown-item active" href="exercise9.html">Exercise 9 - Rate Limiting</a></li>
                                    <li><a class="dropdown-item" href="exercise10.html">Exercise 10 - Delayed Delivery</a></li>
                                    <li><a class="dropdown-item" href="exercise11.html">Exercise 11 - Further patterns to learn</a></li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://github.com/WilliamBZA/1DayDistributedSystemsThroughPlay/tree/main/">Code Repo</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://github.com/WilliamBZA/1DayDistributedSystemsThroughPlay/tree/main/exercises/solutions">Solutions</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>

        <div class="container heading">
            <div>
                <h1>Exercise 9:</h1>
                <h4>Rate limiting</h4>
            </div>
        </div>
        
        <div class="container exercisedetails">
            <div class="col-lg-12">
                <ul class="nav nav-tabs" id="exercise-headings" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="gpio-tab" type="button" data-bs-toggle="tab" data-bs-target="#gpio-tab-content" role="tab" aria-controls="visualstudio-tab-content" aria-selected="false">
                            Slow it down
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="bonusexercise-tab" type="button" data-bs-toggle="tab" data-bs-target="#bonus-exercise-tab-content" role="tab" aria-controls="bonus-exercise-tab-content" aria-selected="true">
                            Bonus exercises
                        </button>
                    </li>
                </ul>
                
                <div class="tab-content" id="exerciseContent">
                    <div class="tab-pane show active" id="gpio-tab-content" role="tabpanel" aria-labelledby="gpio-tab" tabindex="0">
                        <div>
                            Sometimes the bottleneck isn't your code, it's the service you're calling. Maybe it's an external API, maybe it's your own database.
                            Whatever the case, if that service gets overwhelmed, bad things happen fast: timeouts, throttling, maybe even crashes.
                        </div>
                        <div>
                            The good news? You can play nice with those downstream systems by being a bit more polite; that's where <strong>rate limiting</strong> comes in.
                            Polly has a handy built-in rate limiter that lets you say things like: "Only allow 5 calls every second," or "Only 50 requests per minute."
                        </div>
                        <div>
                            In this exercise, we'll use Polly to implement rate limiting for your Azure Service Bus message handler.
                        </div>

                        <h3 class="breadcrumb" id="vs-step1">1. Understand Rate Limiting</h3>
                        <div>
                            Rate limiting ensures that your application doesn't try to process more messages than it can handle. When the limit is reached,
                            your handler temporarily rejects or delays further requests. This helps prevent overwhelming downstream systems like databases or APIs.
                        </div>
                        <div>
                            Let's say your message handler needs to call a payment gateway to charge a credit card. That gateway might have a rate limit of 10 calls per second.
                            If you exceed that, they might start throttling you or rejecting requests outright. Or imagine your handler writes to a shared
                            database that can only handle a certain number of connections. Too many requests in a short time could slow down the entire system, or worse, lock things up.
                        </div>
                        <div>
                            Rate limiting isn't about slowing you down: it's about preventing you from hitting a wall. It gives your downstream systems a
                            breather, and helps your system behave more predictably under pressure.
                        </div>

                        <h3 class="breadcrumb" id="vs-step2">2. Polly's rate limiting support</h3>
                        <div>
                            Polly provides a straightforward way to limit the rate of processing requests. The <code>RateLimitAsync</code> policy lets you define how many executions are
                            allowed in a given time window. If that limit is reached, Polly throws a <code>RateLimitRejectedException</code> to signal that the request should be rejected or retried later.
                        </div>
                        <div>
                            Here's how you might set up a rate limit policy:
                        </div>
                        <div>
                            <pre style="font-family:Cascadia Mono;font-size:13px;color:black;background:white;"><span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">rateLimitPolicy</span>&nbsp;=&nbsp;<span style="color:#066555;">Policy</span>.<span style="color:#74531f;">RateLimitAsync</span>(20,&nbsp;<span style="color:#066555;">TimeSpan</span>.<span style="color:#74531f;">FromSeconds</span>(10));
</pre>
                        </div>
                        <div>
                            This line means: "Allow up to 20 calls every 10 seconds." Once the limit is hit, any more requests during that window will be rejected until the window resets.
                        </div>
                        <div>
                            This is useful when working with systems like:
                            <ul>
                                <li>APIs that enforce quotas or rate limits</li>
                                <li>Databases with limited connection pools</li>
                                <li>Services that slow down under high load</li>
                            </ul>
                        </div>
                        <div>
                            Polly's rate limiting is thread-safe and works well with async code. It queues up tasks internally and enforces the rate,
                            so your handler code doesn't need to worry about counting requests.
                        </div>

                        <h3 class="breadcrumb" id="vs-step3">3. Integrate the Policy into Your Message Handler</h3>
                        <div>
                            Wrap your message handler invocation inside the rate limit policy:
                        </div>
                        <div>
                            <pre style="font-family:Cascadia Mono;font-size:13px;color:black;background:white;"><span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">rateLimitPolicy</span>&nbsp;=&nbsp;<span style="color:#066555;">Policy</span>.<span style="color:#74531f;">RateLimitAsync</span>(20,&nbsp;<span style="color:#066555;">TimeSpan</span>.<span style="color:#74531f;">FromSeconds</span>(10));
<span style="color:#8f08c4;">await</span>&nbsp;<span style="color:#1f377f;">rateLimitPolicy</span>.<span style="color:#74531f;">ExecuteAsync</span>(<span style="color:blue;">async</span>&nbsp;()&nbsp;=&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">await</span>&nbsp;<span style="color:#74531f;">HandleMessageAsync</span>(<span style="color:#1f377f;">message</span>);
});
</pre>
                        </div>
                        <div>
                            This ensures that no more than the configured number of messages are processed within the specified window. If your handler is invoked
                            more frequently than allowed, Polly will throw a <code>RateLimitRejectedException</code>. That exception can be caught and handled by a 
                            <code>WaitAndRetry</code> policy to implement a delay in processing.
                        </div>

                        <h3 class="breadcrumb" id="vs-step4">4. Configure a Polly policy for RateLimitRejectedExceptions</h3>
                        <div>
                            Now let's make our message handler even smarter. If Polly rejects a call because the rate limit has been exceeded, we don't necessarily
                            want to give up immediately. We might just want to wait a moment and try again.
                        </div>
                        <div>
                            To handle this gracefully, we can combine the <code>RateLimitAsync</code> policy with a <code>WaitAndRetryAsync</code> policy that listens for
                            <code>RateLimitRejectedException</code> and applies an appropriate backoff strategy. Here's how to chain them:
                        </div>
                        <div>
                            <pre style="font-family:Cascadia Mono;font-size:13px;color:black;background:white;"><span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">retryOnRateLimit</span>&nbsp;=&nbsp;<span style="color:#066555;">Policy</span>
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="color:#74531f;">Handle</span>&lt;<span style="color:#066555;">RateLimitRejectedException</span>&gt;()
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="color:#74531f;">WaitAndRetryAsync</span>(3,&nbsp;<span style="color:#1f377f;">attempt</span>&nbsp;=&gt;&nbsp;<span style="color:#066555;">TimeSpan</span>.<span style="color:#74531f;">FromSeconds</span>(20));

<span style="color:blue;">var</span>&nbsp;<span style="color:#1f377f;">combinedPolicy</span>&nbsp;=&nbsp;<span style="color:#066555;">Policy</span>.<span style="color:#74531f;">WrapAsync</span>(<span style="color:#1f377f;">retryOnRateLimit</span>,&nbsp;<span style="color:#1f377f;">rateLimitPolicy</span>);

<span style="color:#8f08c4;">await</span>&nbsp;<span style="color:#1f377f;">combinedPolicy</span>.<span style="color:#74531f;">ExecuteAsync</span>(<span style="color:blue;">async</span>&nbsp;()&nbsp;=&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">await</span>&nbsp;<span style="color:#74531f;">HandleMessageAsync</span>(<span style="color:#1f377f;">message</span>);
});
</pre>
                        </div>
                        <div>
                            In this example, if Polly throws a <code>RateLimitRejectedException</code>, the retry policy will wait and try again after 20 seconds. If after three attempts it's
                            still being rate-limited, the exception will bubble up.
                        </div>
                        <div>
                            This pattern gives your system a second chance at success without overwhelming downstream services.
                        </div>

                        <h3 class="breadcrumb" id="vs-step5">5. Testing Your Rate Limiter</h3>
                        <div>
                            Once you've implemented the rate limiting using Polly, it's time to test your rate limiter.
                        </div>
                        <div>
                            To test, simulate sending 100 messages rapidly to your queue. Observe how the rate limit affects processing speed. You should see some messages delayed,
                            preventing your handler from becoming overwhelmed.
                        </div>
                    </div>

                    <div class="tab-pane" id="bonus-exercise-tab-content" rold="tabpanel" aria-labelledby="bonusexercise-tab" tabindex="2">
                        <h3>Bonus round!</h3>

                        <div>
                            Done already? Waiting for everyone else to finish? Why not tackle some of these bonus challenges?
                        </div>

                        <h3 class="breadcrumb">1. What is the relationship between concurrency and rate limiting?</h3>
                        <div>
                            <ul>
                                <li>What happens to the messages that are being rate-limited, waiting for their turn to be processed?</li>
                                <li>What happens when multiple message handlers are running concurrently with the same rate limit policy?</li>
                            </ul>

                            Experiment with changing the concurrency of your message processor.
                        </div>

                        <h3 class="breadcrumb">2. Getting the rate limit wrong</h3>
                        <div>
                            What are the risks of setting your rate limit too low or too high?
                        </div>
                        <div>
                            Explore how your app behaves under pressure. How do low limits affect throughput? What happens when the limit is too generous and downstream services start to complain?
                        </div>

                        <h3 class="breadcrumb">3. Could you dynamically adjust your rate limits at runtime?</h3>
                        <div>
                            Think about how your application could adapt its limits based on telemetry or alerts. How would you build that into a real system?
                        </div>
                    </div>
                    <div class="footer-nav">
                        <a href="exercise8.html">&lt; Go to Exercise 8</a><a href="exercise10.html">Go to Exercise 10 &gt;</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>